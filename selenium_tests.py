# Generated by Selenium IDE
import pandas as pd
import pytest
import time
import json

import selenium.common.exceptions
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.alert import Alert


class Tests:
    def __init__(self, screen_info):
        self.screen_info = screen_info

    def go_to_url(self, url):
        if url != self.driver.current_url:
            self.driver.get(url)

    def check_elements_exist(self, parameters_dict):
        for element in parameters_dict:
            existing_elements = self.driver.find_elements(By.TAG_NAME, element['type'])
            element.pop('type')
            for text_or_attribute_to_search in element.keys():
                match text_or_attribute_to_search:
                    case 'text':
                        existing_elements = [web_element for web_element in existing_elements if web_element.text.upper() == element['text'].upper()]
                        l = 0
            '''
            for key in element.keys():
                if type(key) is not str or (type(key) is str and key != 'type'):
                    if '[@' in xpath_str:
                        xpath_str = xpath_str + ' and [@' + key + '="' + element[key] + '"]'

                    else:
                        xpath_str = xpath_str + '[@' + key + '="' + element[key] + '"]'
            '''
            try:

                l = 0
            except selenium.common.NoSuchElementException:
                pass
        l = 0

    def setup_method(self):
        self.driver = webdriver.Chrome()
        #input('Move the browser to the desired monitor and press Enter when ready to continue')
        self.driver.set_window_position(self.screen_info.x, self.screen_info.y)
        self.driver.maximize_window()
        self.vars = {}

        # Check screen dimensions and modify zoom if necessary. The zoom percentage will be calculated dividing the display width by the required width
        required_width = 3840
        required_height = 2160

        if self.screen_info.width < required_width and self.screen_info.height < required_height:
            self.driver.get('chrome://settings/')
            zoom = self.screen_info.width / required_width  # for example 0.5, or 1.5 or 2.0 and so on
            self.driver.execute_script(f'chrome.settingsPrivate.setDefaultZoom({zoom});')
            self.driver.back()

    def get_driver_version(self):
        print(self.driver.capabilities['version'])

    def teardown_method(self):
        self.driver.quit()

    def test_login(self):
        self.driver.get("https://impact-neo-ced.enaire.es/#/login?redirect=%2Fmain%2Fmaster")
        '''
        elements = self.driver.find_elements(By.XPATH, "//*")
        elements_for_csv = [['Tag', 'Text']]
        for element in elements:
            tmp = []
            tmp.append(element.tag_name)
            tmp.append(element.text)
            elements_for_csv.append(tmp)
        '''
        self.driver.find_element(By.ID, "input-16")
        self.driver.find_element(By.NAME, "user").click()
        self.driver.find_element(By.ID, "input-16").send_keys("jmarrieta")
        self.driver.find_element(By.ID, "password").click()
        self.driver.find_element(By.ID, "password").send_keys("jmarrieta")
        self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
        time.sleep(3)
        self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
        time.sleep(3)
        i = 0
        while i < 5:
            try:
                Alert(self.driver).accept()
                break

            except selenium.common.exceptions.NoAlertPresentException:
                i = i + 1
                time.sleep(5)

        '''
        elements = self.driver.find_elements(By.XPATH, "//*")
        for element in elements:
            tmp = []
            tmp.append(element.tag_name)
            tmp.append(element.text)
            elements_for_csv.append(tmp)

        df = pd.DataFrame(columns=elements_for_csv[0], data=elements_for_csv[1:])
        df.to_csv('etiquetas_detectadas.csv')
        l = 0
        '''
        #time.sleep(10)

    def check_element_is_enabled(self):
        self.driver.find_element(By.ID("elementID")).is_enabled()
