# Generated by Selenium IDE
import os
import re

import pandas as pd
import pytest
import time
import json
from getpass import getpass
from io import StringIO
from lxml import etree
import pickle
from tqdm import tqdm


import selenium.common.exceptions
from selenium import webdriver
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.alert import Alert
from selenium.webdriver.support.relative_locator import RelativeBy
from selenium.webdriver.support import expected_conditions as EC


class Tests:
    def __init__(self, screen_info):
        self.screen_info = screen_info
        self.username = None
        self.password = None
        self.valores_guardados = {}

    def funcion_prueba(self):
        print('Llamada a función de prueba')

    def set_username_and_password(self):
        #self.username = input('Introduce tu nombre de usuario: ')
        #self.password = getpass('Introduce tu contraseña: ')
        self.username = 'jmarrieta'
        self.password = 'jmarrieta'

    def go_to_url(self, url):
        # Vamos a la URL en cuestión si dicha URL es diferente a aquella en que nos encontramos actualmente
        if url != self.driver.current_url:
            self.driver.get(url)

    def pulsar_tecla(self, params):
        match params['tecla'].upper():
            case 'ENTER':
                if 'xpath' in params:
                    self.driver.find_element(By.XPATH, params['xpath']).send_keys(Keys.ENTER)

            case _:
                print('La tecla ' + params['tecla'] + ' no está contemplada')

    def check_horizontal_scroll_present(self):
        self.driver.execute_script('return document.documentElement.scrollWidth>document.documentElement.clientWidth;')

    def check_vertical_scroll_present(self):
        self.driver.execute_script('return document.documentElement.scrollHeight>document.documentElement.clientHeight;')

    def check_language(self):
        language = self.driver.find_element(By.XPATH, "//html").get_attribute('lang')

    def hacer_clic(self, params):
        elemento = self.buscar_elemento(params)
        try:
            elemento.click()

        except (selenium.common.exceptions.ElementNotInteractableException, selenium.common.exceptions.ElementClickInterceptedException):
            self.driver.execute_script('arguments[0].click()', elemento)


    def buscar_elemento(self, params):
        elemento = None

        try:
            if 'xpath' in params.keys():
                elemento = self.driver.find_element(By.XPATH, params['xpath'])

            elif 'type' in params.keys() or 'tag' in params.keys():
                if 'tag' in params.keys():
                    params['type'] = params['tag']
                    params.pop('tag')

                elemento = self.driver.find_element(By.TAG_NAME, params['type'])
                params.pop('type')
                if len(params.keys()) > 1:
                    for text_or_attribute_to_search in params.keys():
                        match text_or_attribute_to_search:
                            case 'text':
                                elemento = [web_element for web_element in elemento if web_element.text.upper() == params['text'].upper()]
                                l = 0

                            case 'attribute':
                                elemento = [web_element for web_element in elemento if web_element.get_attribute(params['attribute'].split('=')[0]) == params['attribute'].split('=')[1]]
                                l = 0

                            case 'id':
                                elemento = [web_element for web_element in elemento if web_element.id == params['id']]
                                l = 0

                            case 'class':
                                #elemento = [web_element for web_element in elemento if web_element.class == params['class']]
                                l = 0
        except selenium.common.exceptions.NoSuchElementException:
            elemento = None

        return elemento
    
    def buscar_elementos(self, params):
        elementos = None
        if 'xpath' in params.keys():
            elementos = self.driver.find_elements(By.XPATH, params['xpath'])

        elif 'type' in params.keys() or 'tag' in params.keys():
            if 'tag' in params.keys():
                params['type'] = params['tag']
                params.pop('tag')

            elementos = self.driver.find_elements(By.TAG_NAME, params['type'])
            params.pop('type')
            if len(params.keys()) > 1:
                for text_or_attribute_to_search in params.keys():
                    match text_or_attribute_to_search:
                        case 'text':
                            elementos = [web_element for web_element in elementos if web_element.text.upper() == params['text'].upper()]
                            l = 0

                        case 'attribute':
                            elementos = [web_element for web_element in elementos if web_element.get_attribute(params['attribute'].split('=')[0]) == params['attribute'].split('=')[1]]
                            l = 0

                        case 'id':
                            elementos = [web_element for web_element in elementos if web_element.id == params['id']]
                            l = 0

                        case 'class':
                            pass

        return elementos

    def buscar_elementos_hijos(self, elemento_padre, params):
        elementos = None
        if 'xpath' in params.keys():
            elementos = elemento_padre.find_elements(By.XPATH, params['xpath'])

        elif 'type' in params.keys() or 'tag' in params.keys():
            if 'tag' in params.keys():
                params['type'] = params['tag']
                params.pop('tag')

            elementos = self.driver.find_elements(By.TAG_NAME, params['type'])
            params.pop('type')
            if len(params.keys()) > 1:
                for text_or_attribute_to_search in params.keys():
                    match text_or_attribute_to_search:
                        case 'text':
                            elementos = [web_element for web_element in elemento if web_element.text.upper() == params['text'].upper()]
                            l = 0

                        case 'attribute':
                            elementos = [web_element for web_element in elemento if web_element.get_attribute(params['attribute'].split('=')[0]) == params['attribute'].split('=')[1]]
                            l = 0

                        case 'id':
                            elementos = [web_element for web_element in elemento if web_element.id == params['id']]
                            l = 0

                        case 'class':
                            pass

        return elementos

    def buscar_elemento_hijo(self, elemento_padre, params):
        elemento = None
        if 'xpath' in params.keys():
            xpath = params['xpath']
            if xpath.startswith('./*') is False:
                xpath = './*' + xpath

            elemento = elemento_padre.find_element(By.XPATH, params['xpath'])

        elif 'type' in params.keys() or 'tag' in params.keys():
            if 'tag' in params.keys():
                params['type'] = params['tag']
                params.pop('tag')

            elemento = self.driver.find_element(By.TAG_NAME, params['type'])
            params.pop('type')
            if len(params.keys()) > 1:
                for text_or_attribute_to_search in params.keys():
                    match text_or_attribute_to_search:
                        case 'text':
                            elemento = [web_element for web_element in elemento if web_element.text.upper() == params['text'].upper()]
                            l = 0

                        case 'attribute':
                            elemento = [web_element for web_element in elemento if web_element.get_attribute(params['attribute'].split('=')[0]) == params['attribute'].split('=')[1]]
                            l = 0

                        case 'id':
                            elemento = [web_element for web_element in elemento if web_element.id == params['id']]
                            l = 0

                        case 'class':
                            pass

        return elemento

    def seleccionar_elemento(self, params, valor_seleccion):
        try:
            elemento = self.buscar_elemento(params=params)[0]
            element_select = Select(elemento)
            element_select.select_by_value(valor_seleccion)

        except selenium.common.exceptions.UnexpectedTagNameException as e:
            print(e.args)

    def setup_method(self):
        # Configuramos para que no notifique acerca de contraseña débil o parecido
        self.chrome_options = webdriver.ChromeOptions()
        prefs = {
            "credentials_enable_service": False,
            "profile.password_manager_leak_detection": False

        }

        self.chrome_options.add_experimental_option("prefs", prefs)
        self.chrome_options.add_argument('start-maximized')
        #self.chrome_options.add_argument('--window-size=' + str(self.screen_info.width) + 'x' + str(self.screen_info.height))

        self.driver = webdriver.Chrome(self.chrome_options)


        #input('Move the browser to the desired monitor and press Enter when ready to continue')
        #self.driver.set_window_size(self.screen_info.width, self.screen_info.height)
        self.driver.set_window_position(self.screen_info.x, self.screen_info.y)
        self.driver.maximize_window()

        self.vars = {}

        # Check screen dimensions and modify zoom if necessary. The zoom percentage will be calculated dividing the display width by the required width
        required_width = 3840
        required_height = 2160

        if self.screen_info.width < required_width and self.screen_info.height < required_height:
            self.driver.get('chrome://settings/')
            zoom = self.screen_info.width / required_width  # for example 0.5, or 1.5 or 2.0 and so on
            self.driver.execute_script(f'chrome.settingsPrivate.setDefaultZoom({zoom});')
            #self.driver.execute_script(f'chrome.profile.password_manager_leak_detection(false);')
            #self.driver.back()
            self.driver.back()

    def get_driver_version(self, min_version=None):
        if min_version is None:
            return self.driver.capabilities['version']

        else:
            return self.driver.capabilities['version'] >= min_version

    def put_remove_full_screen(self, do_twice=False):
        self.driver.find_element(By.XPATH, '/html/body').send_keys(Keys.F11)

        if do_twice:
            self.driver.find_element(By.XPATH, '/html/body').send_keys(Keys.F11)

    def teardown_method(self):
        self.driver.quit()

    def comprobar_visibilidad_elemento(self, params):
        match params['tipo']:
            case 'xpath':
                match params['visible']:
                    case True:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.visibility_of_element_located((By.XPATH, params['esperar']['xpath'])))

                    case False:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.invisibility_of_element_located((By.XPATH, params['esperar']['xpath'])))

                    case _:
                        print('El tipo de visibilidad no coincide con uno de los posibles: true o false')

            case 'class':
                match params['visible']:
                    case True:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.visibility_of_element_located((By.CLASS_NAME, params['tipo']['class'])))

                    case False:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.invisibility_of_element_located((By.CLASS_NAME, params['tipo']['class'])))

                    case _:
                        print('El tipo de visibilidad no coincide con uno de los posibles: true o false')

            case 'id':
                match params['visible']:
                    case True:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.visibility_of_element_located((By.ID, params['tipo']['id'])))

                    case False:
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.invisibility_of_element_located((By.ID, params['tipo']['id'])))

                    case _:
                        print('El tipo de visibilidad no coincide con uno de los posibles: true o false')


    def esperar_elemento(self, params):
        parametro_espera = list(params['esperar'].keys())
        match parametro_espera[0]:
            case 'xpath':
                match params['tipo_espera']:
                    case 'presencia':
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.presence_of_element_located((By.XPATH, params['esperar']['xpath'])))

                    case 'visibilidad':
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.visibility_of_element_located((By.XPATH, params['esperar']['xpath'])))

                    case 'invisibilidad':
                        WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.invisibility_of_element_located((By.XPATH, params['esperar']['xpath'])))

                    case _:
                        print('El tipo de espera no coincide con uno de los posibles: presencia, visibilidad o invisibilidad')

                #WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.visibility_of_element_located((By.XPATH, params['esperar']['xpath'])))

            case 'class':
                WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.presence_of_element_located((By.CLASS_NAME, params['esperar']['class'])))

            case 'id':
                WebDriverWait(self.driver, timeout=100, poll_frequency=1).until(EC.presence_of_element_located((By.ID, params['esperar']['id'])))

    def comprobar_resolucion_pantalla(self,params):
        if params['ancho'] <= self.screen_info.width and params['alto'] <= self.screen_info.height:
            print('La pantalla sobre la que se está ejecutando la herramienta tiene al menos la resolución requerida')

        else:
            print('Alguna de las dimensiones no se corresponde\nResolución requerida:', str(params['ancho']) + 'x' + str(params['alto']), '\nResolución encontrada: ' + str(self.screen_info.width) + 'x' + str(self.screen_info.height))

    def comprobar_version_driver(self, params):
        match list(params.keys())[0]:
            case 'min_version':
                print(int(self.driver.capabilities['browserVersion'].split('.')[0]) >= params['min_version'])

            case 'exact_version':
                print(int(self.driver.capabilities['browserVersion'].split('.')[0]) == params['exact_version'])

    def ir_a_centro(self, url, params):
        # Comprobamos si estamos con sesión iniciada y en el centro deseado
        if self.driver.current_url is not None and self.driver.current_url == url:
            body = self.driver.find_element(By.XPATH, '//body')
            if params['centro'] not in body.get_attribute('innerHTML'):
                self.cerrar_sesion()
                self.iniciar_sesion(params)
                
        # Comprobamos si la sesión no está iniciada
        else:
            self.iniciar_sesion(params)

    def poner_quitar_pantalla_completa(self, params):
        veces = 1
        if 'veces' in params.keys():
            veces = int(params['veces'])

        i = 0
        while i < veces:
            #ActionChains(self.driver).send_keys(Keys.ESCAPE).perform()
            body = self.driver.find_element(By.XPATH, '/html/body')
            body.send_keys(webdriver.Keys.F11)

            if veces > 1:
                time.sleep(5)

            i = i + 1

    def comprobar_contenido_elemento(self, params):
        comprobacion_ok = True
        elemento_encontrado = self.buscar_elemento(params)
        if 'texto' in params.keys() and params['texto'] not in elemento_encontrado.text:
            comprobacion_ok = False

        elif 'regex' in params.keys() and re.search(params['regex'], elemento_encontrado.text) is not None:
            comprobacion_ok = False

        elif 'atributo' in params.keys():
            valor_atributo = elemento_encontrado.get_attribute(params['atributo']['nombre'])
            if valor_atributo != params['atributo']['valor']:
                comprobacion_ok = False

        print(comprobacion_ok)


    def obtener_fecha_y_hora(self, params):
        fecha_y_hora = time.strftime(params['formato'])
        return fecha_hora

    def comprobar_valor_css(self, params):
        comprobacion_ok = False
        elemento = self.buscar_elemento(params)
        valor_css = elemento.value_of_css_property(property_name=params['valor_css'])

        if valor_css == params['valor_comprobacion']:
            comprobacion_ok = True

    def comprobar_contenido_hover(self, params):
        try:
            # Buscamos el elemento sobre el que hacer hover y ponemos el ratón sobre el
            self.hacer_hover(params)

            #time.sleep(1)
            # Esperamos a que esté el elemento deseado presente y después lo buscamos, pues su contenido es el que queremos comprobar
            self.esperar_elemento(params)
            elemento_padre = self.buscar_elemento(params['esperar'])

            # Comprobamos si contiene lo esperado. Puede ser que deba contener todo lo que se dice o basta con que se cumpla uno entre varios
            comprobacion_ok = None
            match params['tipo_comprobacion'].upper():
                case 'Y' | 'AND':
                    comprobacion_ok = True
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)

                        if elemento_encontrado is not None:
                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        else:
                            comprobacion_ok = False

                case 'O' | 'OR':
                    comprobacion_ok = False
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)
                        if elemento_encontrado is not None:
                            comprobacion_ok = True

                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        if comprobacion_ok:
                            break

            print('Comprobacion_ok', comprobacion_ok)

        except selenium.common.exceptions.NoSuchElementException as e:
            print('Error selenium.common.exceptions.NoSuchElementException')

        except selenium.common.exceptions.TimeoutException as e:
            print('Error selenium.common.exceptions.TimeoutException')

        l = 0

    def rellenar_campo(self, params):
        elemento = self.buscar_elemento(params)
        if 'xpath' not in params['valor'].keys():
            elemento.send_keys(params['valor'])

        else:
            pass

    def comprobar_contenido_elementos(self, params):
        try:
            # Buscamos los elementos sobre el que comprobar_contenido, que contendrán la misma clase o algún otro parámetro en común
            elementos = self.buscar_elementos(params)

            for elemento in elementos:
                elemento_web = self.buscar_elemento(elemento)
                # Comprobamos si contiene lo esperado. Puede ser que deba contener la totalidad de lo que se dice o basta con que se cumpla uno entre varios
                comprobacion_ok = None
                match params['tipo_comprobacion'].upper():
                    case 'Y' | 'AND':
                        comprobacion_ok = True
                        for params_hijo in params['contenido']:
                            elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)

                            if elemento_encontrado is not None:
                                if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                    comprobacion_ok = False

                                elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                    comprobacion_ok = False

                            else:
                                comprobacion_ok = False

                    case 'O' | 'OR':
                        comprobacion_ok = False
                        for params_hijo in params['contenido']:
                            elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)
                            if elemento_encontrado is not None:
                                comprobacion_ok = True

                                if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                    comprobacion_ok = False

                                elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                    comprobacion_ok = False

                            if comprobacion_ok:
                                break

                print('Comprobacion_ok', comprobacion_ok)

        except selenium.common.exceptions.NoSuchElementException as e:
            print('Error selenium.common.exceptions.NoSuchElementException')

        except selenium.common.exceptions.TimeoutException as e:
            print('Error selenium.common.exceptions.TimeoutException')

        l = 0

    def comprobar_contenido_elemento_2(self, params):
        try:
            # Buscamos los elementos sobre el que comprobar_contenido, que contendrán la misma clase o algún otro parámetro en común
            elemento_padre = self.buscar_elemento(params)

            comprobacion_ok = None
            match params['tipo_comprobacion'].upper():
                case 'Y' | 'AND':
                    comprobacion_ok = True
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)

                        if elemento_encontrado is not None:
                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        else:
                            comprobacion_ok = False

                case 'O' | 'OR':
                    comprobacion_ok = False
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)
                        if elemento_encontrado is not None:
                            comprobacion_ok = True

                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        if comprobacion_ok:
                            break

            print('Comprobacion_ok', comprobacion_ok)

        except selenium.common.exceptions.NoSuchElementException as e:
            print('Error selenium.common.exceptions.NoSuchElementException')

        except selenium.common.exceptions.TimeoutException as e:
            print('Error selenium.common.exceptions.TimeoutException')

        l = 0

    def comprobar_url_actual(self, params):
        print(params['url_comprobacion'] == self.driver.current_url)

    def comprobar_contenido_dialogo(self, params):
        try:
            # Buscamos el elemento sobre el que comprobar_contenido
            elemento = self.buscar_elemento(params)

            #time.sleep(1)
            # Esperamos a que esté el elemento deseado presente y después lo buscamos, pues su contenido es el que queremos comprobar
            self.esperar_elemento(params)
            elemento_padre = self.buscar_elemento(params['esperar'])

            # Comprobamos si contiene lo esperado. Puede ser que deba contener la totalidad de lo que se dice o basta con que se cumpla uno entre varios
            comprobacion_ok = None
            match params['tipo_comprobacion'].upper():
                case 'Y' | 'AND':
                    comprobacion_ok = True
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)

                        if elemento_encontrado is not None:
                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        else:
                            comprobacion_ok = False

                case 'O' | 'OR':
                    comprobacion_ok = False
                    for params_hijo in params['contenido']:
                        elemento_encontrado = self.buscar_elemento_hijo(elemento_padre, params_hijo)
                        if elemento_encontrado is not None:
                            comprobacion_ok = True

                            if 'texto' in params_hijo and params_hijo['texto'] not in elemento_encontrado.text:
                                comprobacion_ok = False

                            elif 'regex' in params_hijo and re.search(params_hijo['regex'], elemento_encontrado.text) is not None:
                                comprobacion_ok = False

                        if comprobacion_ok:
                            break

            print('Comprobacion_ok', comprobacion_ok)

        except selenium.common.exceptions.NoSuchElementException as e:
            print('Error selenium.common.exceptions.NoSuchElementException')

        except selenium.common.exceptions.TimeoutException as e:
            print('Error selenium.common.exceptions.TimeoutException')

        l = 0

    def mover_elemento(self, params):
        elements = self.driver.find_elements(By.XPATH, '//div[@class="tab-ws"]')
        element_drag = WebDriverWait(self.driver, 60).until(
            EC.element_to_be_clickable(elements[0]))
        ActionChains(self.driver).drag_and_drop_by_offset(element_drag, 50, 0).perform()

    def test_login(self, params):
        if self.username is None:
            self.set_username_and_password()

        #self.driver.get("https://impact-neo-ced.enaire.es/#/login?redirect=%2Fmain%2Fmaster")
        self.driver.get('https://impact-formacion.enaire.es/')

        login_type = params['login_type']
        match login_type:
            case 'correct_login':
                # Introducimos nombre de usuario
                self.driver.find_element(By.ID, "input-16").send_keys(self.username)

                # Introducimos contraseña
                self.driver.find_element(By.ID, "password").send_keys(self.password)

                # Hacemos clic en el botón de login
                self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
                self.driver.find_element(By.XPATH, '/html/body').send_keys(Keys.F11)
                time.sleep(3)

            case 'empty_fields':
                # User y password vacías
                #self.driver.find_element(By.ID, "input-16")
                #self.driver.find_element(By.NAME, "user").click()
                self.driver.find_element(By.ID, "input-16").send_keys('')
                #self.driver.find_element(By.ID, "password").click()
                self.driver.find_element(By.ID, "password").send_keys('')
                self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
                time.sleep(3)

            case 'empty_password':
                # User correcto y password vacío
                #self.driver.find_element(By.ID, "input-16")
                #self.driver.find_element(By.NAME, "user").click()
                self.driver.find_element(By.ID, "input-16").send_keys(self.username)
                #self.driver.find_element(By.ID, "password").click()
                self.driver.find_element(By.ID, "password").send_keys('')
                self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
                time.sleep(3)

            case 'empty_username':
                # User correcto y password vacío
                #self.driver.find_element(By.ID, "input-16")
                #self.driver.find_element(By.NAME, "user").click()
                self.driver.find_element(By.ID, "input-16").send_keys('')
                #self.driver.find_element(By.ID, "password").click()
                self.driver.find_element(By.ID, "password").send_keys(self.password)
                self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
                time.sleep(3)

            case 'wrong_input':
                # User vacío y password correcto
                #self.driver.find_element(By.ID, "input-16")
                #self.driver.find_element(By.NAME, "user").click()
                self.driver.find_element(By.ID, "input-16").send_keys('aaaaaaaaaaaaaaaaaaa')
                #self.driver.find_element(By.ID, "password").click()
                self.driver.find_element(By.ID, "password").send_keys('bbbbbbbbbb')
                self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
                time.sleep(3)
                i = 0

        if 'centro' in params.keys():
            #elemento = self.driver.find_element(By.XPATH, '//span[@class="dl-ui-select__label dl-ui-select__inputtext"]')
            params = {'xpath': '//span[@class="dl-ui-select__label dl-ui-select__inputtext"]'}
            self.hacer_clic(params)

            match params['centro']:
                case 'GCCC' | 'Canarias' | 'CANARIAS':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="GCCC"]').click()

                case 'LECB' | 'Barcelona' | 'BARCELONA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECB"]').click()

                case 'LECM' | 'Madrid' | 'MADRID':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECM"]').click()

                case 'LECP' | 'Palma' | 'PALMA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECP"]').click()

                case 'LECS' | 'Sevilla' | 'SEVILLA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECS"]').click()

            self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
            self.driver.find_element(By.XPATH, '/html/body').send_keys(Keys.F11)

        '''
        i = 0
        while i < 5:
            try:
                wait = WebDriverWait(self.driver, timeout=2)
                alert = wait.until(lambda message: message.switch_to.alert)
                alert.accept()
                break

            except selenium.common.exceptions.NoAlertPresentException:
                i = i + 1
                time.sleep(5)
        '''
        time.sleep(30)
        #self.driver.implicitly_wait(30)

    def create_desktop(self):
        pass

    def check_max_desktops(self, params):
        pass

    def check_cerrar_sesion(self):
        # Esperamos a que se pueda presionar el botón y que exista
        try:
            elemento = WebDriverWait(self.driver, 30).until(EC.presence_of_element_located((By.XPATH, '//div[@id="user"]//*/span/*[local-name()="svg"]/*[local-name()="path"]')))
            elements = self.driver.find_elements(By.XPATH, '//div[@id="user"]//*/span/*[local-name()="svg"]/*[local-name()="path"]')
            elements[-1].click()
        except selenium.common.TimeoutException:
            print('No se ha conseguido acceder al botón de cierre de sesión en 30seg')
            return None

        try:
            #elemento = WebDriverWait(self.driver, 30).until(EC.presence_of_element_located((By.XPATH, '//div[@id="app"]/div/div/div/footer/button')))
            self.esperar_elemento({'esperar': {'xpath': '//div[@id="app"]/div/div/div/footer/button'}, 'tipo_espera': 'presencia'})
            self.hacer_clic({'xpath': '//div[@id="app"]/div/div/div/footer/button'})

        except selenium.common.TimeoutException:
            print('No se ha conseguido acceder al botón de confirmación de cierre de sesión en 30seg')
            return None

        #elemento = self.driver.find_element(By.XPATH, '//div[@id="app"]/div/div/div/footer/button')
        #self.hacer_clic(elemento)

    def guardar_df_como_excel(self, df, nombre_fichero, aplicar_filtro=True, aplicar_colorizacion=True):
        intentar_guardar = True

        # Creamos una lista vacía que contendrá los DataFrames, pudiendo ser uno o varios en función del número de filas que tenga
        # El motivo de esta acción es, además de evitar que supere el tamaño máximo permitido, poder abrir el fichero en excel
        dfs = []
        if len(df) > 10000:
            i = 0
            while i < len(df):
                if i + 10000 < len(df):
                    dfs.append(df[i:i + 10000])

                else:
                    dfs.append(df[i:])

                i = i + 10000

        else:
            dfs.append(df)

        i = 0
        while i < len(dfs):
            while intentar_guardar:
                try:
                    excel_writer = pd.ExcelWriter(nombre_fichero.replace('.xlsx', '_' + str(i) + '.xlsx'))

                    dfs[i].to_excel(excel_writer=excel_writer, sheet_name=nombre_fichero.replace('.xlsx', ''), index=None)
                    workbook = excel_writer.book
                    worksheet = excel_writer.sheets[nombre_fichero.replace('.xlsx', '')]

                    # Calculamos el ancho de la columna, que ayudará a poder visualizar el contenido sin tener que modificar en excel
                    columnas_hoja = dfs[i].columns.tolist()
                    for column_name in columnas_hoja:
                        ancho_columna = len(column_name)
                        valores_columna = dfs[i][column_name]
                        valores_columna.fillna('', inplace=True)
                        if valores_columna.dtype is str or valores_columna.dtype is object:
                            valores_columna.fillna('', inplace=True)

                        elif valores_columna.dtype is int or valores_columna.dtype is float:
                            valores_columna.fillna(0, inplace=True)

                        if len(max(valores_columna, key=len)) > ancho_columna:
                            ancho_columna = len(max(valores_columna, key=len))

                        column_length = ancho_columna + 6
                        column_pos = columnas_hoja.index(column_name)
                        worksheet.set_column(column_pos, column_pos, column_length)

                    # Colorear celdas de filas impares si se indica por parámetro. Puede ser útil para mejorar visualización del fichero excel
                    if aplicar_colorizacion:
                        formato_celda = workbook.add_format()
                        formato_celda.set_bg_color('c5d9f1')

                        j = 1
                        rows_indexes = df.index.tolist()
                        while j < len(df):
                            if j % 2 != 0:
                                k = 0
                                while k < len(columnas_hoja):
                                    value_to_modify = df.loc[rows_indexes[j]][columnas_hoja[k]]
                                    worksheet.write(j + 1, k, value_to_modify, formato_celda)
                                    k = k + 1

                            j = j + 1

                    # Aplicar filtros si se indica, equivalente a ir a Datos -> Filtro en Excel
                    if aplicar_filtro:
                        worksheet.autofilter(0, 0, len(df), len(columnas_hoja) - 1)

                    # Sustituimos el nombre del fichero en la columna PNG por el contenido de la imagen en la propia celda
                    fila = 1
                    while fila <= len(df):
                        fichero_imagen = df.loc[fila-1]['PNG']
                        if fichero_imagen is not None and fichero_imagen != '':
                            try:
                                worksheet.embed_image(fila, df.columns.tolist().index('PNG'), fichero_imagen)

                            except (FileNotFoundError, Exception) as e:
                                print(e)
                                pass

                        fila = fila + 1

                    # Terminamos de guardar el fichero. Si fuese bien, deja de intentar guardar porque ya lo hizo
                    excel_writer.close()
                    intentar_guardar = False

                except PermissionError:
                    print('¡Error, parece que el fichero ' + nombre_fichero + ' se encuentra abierto! Cierre el fichero para poder guardarlo')
                    time.sleep(10)

            i = i + 1

    def obtener_xpath_de_html(self, contenido_html):
        contenido_html = contenido_html.split('<')
        xpath_a_devolver = '//' + re.sub(r'data.+""\s', '', contenido_html[1][:contenido_html[1].index('>')])

        xpaths_especiales = ['svg', 'path']
        if xpath_a_devolver.split()[0].replace('//', '') in xpaths_especiales:
            xpath_a_devolver = xpath_a_devolver.replace(xpath_a_devolver.split()[0], '//*[name()="' + xpath_a_devolver.split()[0].replace('//', '') + '"]')

        xpath_a_devolver = re.sub(r'"\s', '"][@', xpath_a_devolver)
        xpath_a_devolver = xpath_a_devolver.replace(' ', '[@', 1)
        if '[' in xpath_a_devolver:
            xpath_a_devolver = xpath_a_devolver + ']'

        try:
            texto_elemento = contenido_html[1]
            texto_elemento = texto_elemento[texto_elemento.index('>') + 1:]
            texto_elemento = re.sub(r'^\s{1,}|\s{1,}$', '', texto_elemento)
            if len(texto_elemento) > 0 and re.search(r'(text\(\)\,\s"\d+:\d+)', xpath_a_devolver) is None and re.search(r'(text\(\),\s"\d+\/\d+\/\d+)', xpath_a_devolver) is None:
                xpath_a_devolver = xpath_a_devolver + '[contains(text(), "' + texto_elemento + '")]'

        except (IndexError, ValueError):
            # Se da el error si es un único tag sin otro a continuación o sin texto: No necesitamos hacer nada, por lo que puede ignorarse
            pass

        return xpath_a_devolver

    def obtener_xpaths_de_html(self, contenido_html):
        posibles_xpaths = []

        contenido_html_en_lista = contenido_html.split('><')
        contenido_html_en_lista = [('<' + contenido) if contenido.startswith('<') is False else contenido for contenido in contenido_html_en_lista]
        contenido_html_en_lista = [(contenido + '>') if contenido.endswith('>') is False else contenido for contenido in contenido_html_en_lista]

        # Generamos en primer lugar un xpath a partir de cada una de las etiquetas
        i = 0
        while i < len(contenido_html_en_lista):
            if contenido_html_en_lista[i].startswith('<!') is False:
                posibles_xpaths.append(self.obtener_xpath_de_html(contenido_html_en_lista[i]))

            i = i + 1

        l = 0
        return posibles_xpaths


    def obtener_xpath_de_elemento(self, elemento):
        excepciones_nombre_tag = ['svg', 'path']
        if elemento.tag_name not in excepciones_nombre_tag:
            xpath_a_devolver = '//' + elemento.tag_name

        else:
            xpath_a_devolver = '//*[name()="' + elemento.tag_name + '"]'

        atributos = self.driver.execute_script('var items = {}; for (index = 0; index < arguments[0].attributes.length; ++index) { items[arguments[0].attributes[index].name] = arguments[0].attributes[index].value }; return items;', elemento)
        if atributos is not None and len(atributos.keys()) > 0:
            # Comprobamos en primer lugar si el elemento tuviese un id, en cuyo caso se toma solo ese atributo dado que es un valor único
            if 'id' in atributos:
                xpath_a_devolver = xpath_a_devolver + '[@id="' + elemento.get_attribute('id') + '"]'

            else:
                for atributo in atributos:
                    if elemento.get_attribute(atributo) is not None and elemento.get_attribute(atributo) != '':
                        xpath_a_devolver = xpath_a_devolver + '[@' + atributo + '="' + elemento.get_attribute(atributo) + '"]'

        try:
            outer_html = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""', '', elemento.get_attribute('outerHTML'))
            texto_elemento = outer_html.split('<')[1]
            texto_elemento = texto_elemento[texto_elemento.index('>') + 1:]
            texto_elemento = re.sub(r'^\s{1,}|\s{1,}$', '', texto_elemento)
            if 'Last Update' in elemento.text and '\n' not in elemento.text:
                l = 0

            if len(texto_elemento) > 0 and re.search(r'(text\(\)\,\s"\d+:\d+)', xpath_a_devolver) is None and re.search(r'(text\(\),\s"\d+\/\d+\/\d+)', xpath_a_devolver) is None:
                xpath_a_devolver = xpath_a_devolver + '[contains(text(), "' + texto_elemento + '")]'

        except (IndexError, ValueError):
            # Se da el error si es un único tag sin otro a continuación: No necesitamos hacer nada, por lo que puede ignorarse
            pass

        return xpath_a_devolver

    def obtener_xpaths_voraz(self, df_xpaths):
        datos_elementos_no_repetibles = None

        # Comprobamos si ya existen datos almacenados para no empezar desde cero innecesariamente
        try:
            with open('df_xpaths.pickle', mode='rb') as fichero_pickle:
                df_xpaths = pickle.load(fichero_pickle)

                # Creamos unas listas de elementos cuyos valores y etiquetas o xpaths son cambiantes y bastaría con tener uno a modo de ejemplo
                datos_elementos_no_repetibles = ['class="app"', 'hist-cell TRANSPARENT', 'Total flights', 'hist-cell ifr-arr', 'A2SA', 'A1SR4', 'GCCC', 'PREOPS', 'nmOTMVPeriodPeak', 'timeline', 'rowFL']

                for dato_no_repetible in datos_elementos_no_repetibles:
                    existe = df_xpaths['XPATH'].str.contains(dato_no_repetible)
                    if existe.any() is False:
                        datos_elementos_no_repetibles.remove(dato_no_repetible)

        # Si se produce un error, se debe a que no existe el fichero. Lo capturamos y no hacemos nada
        except FileNotFoundError:
            pass

        # Creamos el directorio que contendrá las capturas
        os.makedirs(os.getcwd() + '\\capturas', exist_ok=True)

        #df_xpaths = pd.DataFrame(columns=['XPATH', 'CONTENIDO HTML', 'XPATHS_CONTENIDO_HTML', 'PALABRAS CLAVE', 'PNG'])
        #xpaths = []
        params = {'esperar': {'xpath': '//div[contains(@class,"tab-ws")]'}, 'tipo_espera': 'presencia'}
        self.esperar_elemento(params)
        time.sleep(5)
        #self.driver.get('https://impact-neo-ced.enaire.es/#/main/master')
        self.driver.get('https://impact-formacion.enaire.es/')

        # En caso de estar actualizándose los datos, esperamos a que finalice
        params = {'esperar': {'xpath': '//div[@class="v-card__text"][contains(text(), "Please stand by")]'}, 'tipo_espera': 'invisibilidad'}
        self.esperar_elemento(params)

        # Guardamos el contenido HTML, que nos servirá posteriormente para detectar otros posibles xpaths
        # Sustituimos valores de fecha y hora, ya que pueda hacer que parezca que dos etiquetas son distintas cuando la diferencia es la hora actial
        contenido_html = re.sub(r'\d+:\d+|\d+\/\d+\/\d+', '', self.driver.page_source)
        contenido_html = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', contenido_html)

        try:
            if len(df_xpaths) == 0:
                # Buscamos todos los elementos que haya en la página
                elementos_encontrados = self.driver.find_elements(By.XPATH, '//body//*')

                tags_a_eliminar = ['html', 'link', 'title', 'style', 'script', 'head', 'meta']
                elementos_encontrados = [elemento for elemento in elementos_encontrados if elemento is not None and elemento.tag_name is not None and elemento.tag_name not in tags_a_eliminar]

                for elemento in tqdm(elementos_encontrados, unit='xpath', total=len(elementos_encontrados)):
                    try:
                        xpath_a_aniadir = self.obtener_xpath_de_elemento(elemento)

                        if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():
                            try:
                                contenido_html_sin_separar = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', elemento.get_attribute('outerHTML'))
                                xpaths_contenido_html = self.obtener_xpaths_de_html(contenido_html_sin_separar)

                                # Obtenemos las palabras clave, que serán de utilidad para poder buscar los xpaths necesarios
                                palabras_clave = re.findall(r'\b\w+\b', xpath_a_aniadir)
                                palabras_clave.append(re.sub(r'\d+\/\d+\/\d+|\d{2}:\d{2}', '', elemento.text).replace('\n\n', ',').replace('\n', ','))

                                j = 10
                                while j < len(palabras_clave):
                                    palabras_clave.insert(j, '\n')

                                    j = j + 10

                                # Eliminamos los valores repetidos, ya que en este caso no es necesario tener valores duplicados
                                palabras_clave = list(set(palabras_clave))
                                palabras_clave = ','.join(palabras_clave)

                                # Guardamos la imagen en un fichero, cuyo nombre será el del índice si se hizo captura
                                if type(elemento.screenshot_as_png) is bytes:
                                    nombre_fichero_imagen = os.getcwd() + '\\capturas\\captura' + str(len(df_xpaths)) + '.png'
                                    elemento.screenshot(nombre_fichero_imagen)
                                    df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, nombre_fichero_imagen, '', palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']

                                else:
                                    df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', '',  palabras_clave, contenido_html_sin_separar,  '\n'.join(xpaths_contenido_html), '']

                            except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                                df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', '',  palabras_clave, contenido_html_sin_separar, '', '']

                    except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                        pass

            # Convertimos contenido_html a lista, pues posteriormente se utilizará para comprobar si acciones como un clic hace que se muestre nuevo contenido
            contenido_html = contenido_html.split('><')
            contenido_html = [('<' + contenido) if contenido.startswith('<') is False else contenido for contenido in contenido_html]
            contenido_html = [(contenido + '>') if contenido.endswith('>') is False else contenido for contenido in contenido_html]

            acciones = ['clic_derecho', 'hover', 'clic']

            # Ya obtenidos los xpath de la web, ejecutamos las acciones de clic, clic derecho y hover y buscamos posibles xpaths a añadir
            barra_progreso = tqdm(total=len(df_xpaths), unit='xpath(s)')
            i = 0
            while i < len(df_xpaths):
                if df_xpaths.loc[i]['REVISADO'] != 'SI':
                    for accion in acciones:
                        if accion == acciones[-1]:
                            # Lo marcamos como revisado para, en caso de retomar el proceso, no volver a hacer lo ya realizado
                            df_xpaths.loc[i]['REVISADO'] = 'SI'

                        try:
                            # En caso de estar actualizándose los datos, esperamos a que finalice
                            params = {'esperar': {'xpath': '//div[@class="v-card__text"][contains(text(), "Please stand by")]'}, 'tipo_espera': 'invisibilidad'}
                            self.esperar_elemento(params)

                            match accion:
                                case 'clic':
                                    # Hacemos clic sobre el elemento
                                    self.hacer_clic({'xpath': df_xpaths.loc[i]['XPATH']})

                                case 'clic_derecho':
                                    # Hacemos clic derecho sobre el elemento
                                    self.hacer_clic_derecho({'xpath': df_xpaths.loc[i]['XPATH']})

                                case 'hover':
                                     # Intentamos hacer hover sobre el elemento
                                     self.hacer_hover({'xpath': df_xpaths.loc[i]['XPATH']})

                            # Obtenemos el nuevo contenido HTML eliminando datos de fecha y/o hora y comparamos con el almacenado para ver si es diferente
                            # En primer lugar, eliminamos etiquetas de comentarios y datos de fecha y hora que puedan hacer que hay diferencias que para análisis no deberían existir en realidad
                            nuevo_contenido_html = re.sub(r'\d+:\d+|\d+\/\d+\/\d+', '', self.driver.page_source).replace('<!---->', '')
                            nuevo_contenido_html = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', nuevo_contenido_html)
                            nuevo_contenido_html = nuevo_contenido_html.split('><')
                            nuevo_contenido_html = [('<' + contenido) if contenido.startswith('<') is False else contenido for contenido in nuevo_contenido_html]
                            nuevo_contenido_html = [(contenido + '>') if contenido.endswith('>') is False else contenido for contenido in nuevo_contenido_html]

                            # Eliminamos aquello que no sea diferente o nuevo
                            nuevo_contenido_html = [contenido for contenido in nuevo_contenido_html if contenido not in contenido_html]

                            # Eliminamos aquellos elementos que puedan considerarse repetidos
                            j = 0
                            while j < len(datos_elementos_no_repetibles):
                                k = 0
                                while k < len(nuevo_contenido_html):
                                    if nuevo_contenido_html[k] in datos_elementos_no_repetibles[j]:
                                        datos_elementos_no_repetibles.remove(datos_elementos_no_repetibles[j])

                                    else:
                                        k = k + 1

                                j = j + 1

                            for contenido in nuevo_contenido_html:
                                xpath_a_aniadir = self.obtener_xpath_de_html(contenido)

                                if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():
                                    try:
                                        # Buscamos todos los elementos que haya en la página
                                        elementos_encontrados = self.driver.find_elements(By.XPATH, xpath_a_aniadir + '//*')
                                        elementos_encontrados = [elemento for elemento in elementos_encontrados if elemento.tag_name not in tags_a_eliminar]

                                        for elemento in elementos_encontrados:
                                            try:
                                                xpath_a_aniadir = self.obtener_xpath_de_elemento(elemento)

                                                if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():# and '[' in xpath_a_aniadir:
                                                    try:
                                                        contenido_html_sin_separar = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', elemento.get_attribute('outerHTML'))
                                                        xpaths_contenido_html = self.obtener_xpaths_de_html(contenido_html_sin_separar)

                                                        # Obtenemos las palabras clave, que serán de utilidad para poder buscar los xpaths necesarios
                                                        palabras_clave = re.findall(r'\b\w+\b', xpath_a_aniadir)
                                                        palabras_clave.append(re.sub(r'\d+\/\d+\/\d+|\d{2}:\d{2}', '', elemento.text).replace('\n\n', ',').replace('\n', ','))

                                                        j = 10
                                                        while j < len(palabras_clave):
                                                            palabras_clave.insert(j, '\n')

                                                            j = j + 10

                                                        # Eliminamos los valores repetidos, ya que en este caso no es necesario tener valores duplicados
                                                        palabras_clave = list(set(palabras_clave))
                                                        palabras_clave = ','.join(palabras_clave)

                                                        # Si el botón de Cancelar, Cerrar o No está presente y estamos en la acción de clic, haremos clic sobre él para poder continuar
                                                        if accion == 'clic' and ('CANCEL' in xpath_a_aniadir.upper()) or ('CLOSE' in xpath_a_aniadir.upper()) or ('NO' in xpath_a_aniadir.upper()):
                                                            self.hacer_clic({'xpath': xpath_a_aniadir})

                                                        # Guardamos la imagen en un fichero, cuyo nombre será el del índice si se hizo captura
                                                        if type(elemento.screenshot_as_png) is bytes:
                                                            nombre_fichero_imagen = os.getcwd() + '\\capturas\\captura' + str(len(df_xpaths)) + '.png'
                                                            df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, nombre_fichero_imagen, df_xpaths.loc[i]['XPATH'], palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']

                                                            # Guardamos la imagen en un fichero, cuyo nombre será el del índice
                                                            elemento.screenshot(nombre_fichero_imagen)

                                                    except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                                                        df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', df_xpaths.loc[i]['XPATH'], palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']

                                            except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException, selenium.common.exceptions.ElementClickInterceptedException):
                                                pass

                                    except (selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.InvalidSelectorException, selenium.common.exceptions.ElementClickInterceptedException):
                                        pass

                        except (AttributeError, selenium.common.exceptions.ElementNotInteractableException,selenium.common.exceptions.ElementClickInterceptedException):
                            pass

                        # En caso de que suceda algún error no contemplado, lo capturamos para poder guardar todo lo que se haya encontrado
                        except Exception:
                            # Guardamos fichero pickle para, en caso de volver a ejecutar, poder hacerlo desde donde nos hubiésemos quedado
                            with open('df_xpaths.pickle', mode='wb') as fichero_pickle:
                                pickle.dump(df_xpaths, fichero_pickle)

                            # Acciones como CTRL+C provocan este error. Lo capturamos para poder guardar lo hecho y por si se quiere revisar durante el proceso que va por buen camino
                            print('Se ha detectado la ejecución de CTRL+C. Guardando hasta lo obtenido')
                            self.guardar_df_como_excel(df_xpaths, 'xpaths.xlsx')

                i = i + 1
                barra_progreso.total = len(df_xpaths)
                barra_progreso.update(1)

            barra_progreso.close()

            # Guardamos el fichero Excel
            self.guardar_df_como_excel(df_xpaths, 'xpaths.xlsx')

        except KeyboardInterrupt:
            # Guardamos fichero pickle para, en caso de volver a ejecutar, poder hacerlo desde donde nos hubiésemos quedado
            with open('df_xpaths.pickle', mode='wb') as fichero_pickle:
                pickle.dump(df_xpaths, fichero_pickle)

            # Acciones como CTRL+C provocan este error. Lo capturamos para poder guardar lo hecho y por si se quiere revisar durante el proceso que va por buen camino
            print('Se ha detectado la ejecución de CTRL+C. Guardando hasta lo obtenido')
            self.guardar_df_como_excel(df_xpaths, 'xpaths.xlsx')

            return 'parado'

    def obtener_xpaths_asistido(self, df_xpaths):
        datos_elementos_no_repetibles = None

        # Comprobamos si ya existen datos almacenados para no empezar desde cero innecesariamente
        try:
            with open('df_xpaths.pickle', mode='rb') as fichero_pickle:
                df_xpaths = pickle.load(fichero_pickle)

                # Creamos unas listas de elementos cuyos valores y etiquetas o xpaths son cambiantes y bastaría con tener uno a modo de ejemplo
                datos_elementos_no_repetibles = ['hist-cell TRANSPARENT', 'Total flights', 'hist-cell ifr-arr', 'A2SA', 'A1SR4', 'GCCC', 'PREOPS', 'nmOTMVPeriodPeak', 'timeline', 'rowFL']

                for dato_no_repetible in datos_elementos_no_repetibles:
                    existe = df_xpaths['XPATH'].str.contains(dato_no_repetible)
                    if existe.any() is False:
                        datos_elementos_no_repetibles.remove(dato_no_repetible)

        # Si se produce un error, se debe a que no existe el fichero. Lo capturamos y no hacemos nada
        except FileNotFoundError:
            pass

        # Creamos el directorio que contendrá las capturas
        os.makedirs(os.getcwd() + '\\capturas', exist_ok=True)

        #df_xpaths = pd.DataFrame(columns=['XPATH', 'CONTENIDO HTML', 'XPATHS_CONTENIDO_HTML', 'PALABRAS CLAVE', 'PNG'])
        #xpaths = []
        params = {'esperar': {'xpath': '//div[contains(@class,"tab-ws")]'}, 'tipo_espera': 'presencia'}
        self.esperar_elemento(params)
        time.sleep(5)
        #self.driver.get('https://impact-neo-ced.enaire.es/#/main/master')
        self.driver.get('https://impact-formacion.enaire.es/')

        # En caso de estar actualizándose los datos, esperamos a que finalice
        params = {'esperar': {'xpath': '//div[@class="v-card__text"][contains(text(), "Please stand by")]'}, 'tipo_espera': 'invisibilidad'}
        self.esperar_elemento(params)

        # Guardamos el contenido HTML, que nos servirá posteriormente para detectar otros posibles xpaths
        # Sustituimos valores de fecha y hora, ya que pueda hacer que parezca que dos etiquetas son distintas cuando la diferencia es la hora actial
        contenido_html = re.sub(r'\d+:\d+|\d+\/\d+\/\d+', '', self.driver.page_source)
        contenido_html = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', contenido_html)

        salir = False
        while salir is False:
            try:
                # Preguntamos al usuario por el xpath a buscar
                xpath_a_buscar = input('Introduzca el xpath a buscar, o escriba salir para finalizar: ')
                
                if 'salir' in xpath_a_buscar:
                    salir = True
                    break
                
                # Si el xpath indicado no acaba en //*, se lo añadimos para que busque el contenido dentro del tag
                if xpath_a_buscar.endswith('//*') is False:
                    xpath_a_buscar = xpath_a_buscar + '//*'
                
                # Buscamos todos los elementos que haya en la página a partir del xpath dado
                elementos_encontrados = self.driver.find_elements(By.XPATH, xpath_a_buscar)
    
                tags_a_eliminar = ['html', 'link', 'title', 'style', 'script', 'head', 'meta']
                elementos_encontrados = [elemento for elemento in elementos_encontrados if elemento.tag_name not in tags_a_eliminar]
    
                for elemento in tqdm(elementos_encontrados, unit='xpath', total=len(elementos_encontrados)):
                    try:
                        xpath_a_aniadir = self.obtener_xpath_de_elemento(elemento)
    
                        if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():
                            try:
                                contenido_html_sin_separar = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', elemento.get_attribute('outerHTML'))
                                xpaths_contenido_html = self.obtener_xpaths_de_html(contenido_html_sin_separar)

                                # Obtenemos las palabras clave, que serán de utilidad para poder buscar los xpaths necesarios
                                palabras_clave = re.findall(r'\b\w+\b', xpath_a_aniadir)
                                palabras_clave.append(re.sub(r'\d+\/\d+\/\d+|\d{2}:\d{2}', '', elemento.text).replace('\n\n', ',').replace('\n', ','))

                                j = 10
                                while j < len(palabras_clave):
                                    palabras_clave.insert(j, '\n')

                                    j = j + 10

                                # Eliminamos los valores repetidos, ya que en este caso no es necesario tener valores duplicados
                                palabras_clave = list(set(palabras_clave))
                                palabras_clave = ','.join(palabras_clave)

                                # Guardamos la imagen en un fichero, cuyo nombre será el del índice si se hizo captura
                                if type(elemento.screenshot_as_png) is bytes:
                                    nombre_fichero_imagen = os.getcwd() + '\\capturas\\captura' + str(len(df_xpaths)) + '.png'
                                    elemento.screenshot(nombre_fichero_imagen)
                                    df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, nombre_fichero_imagen, xpath_a_buscar, palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']
    
                                else:
                                    df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', xpath_a_buscar,  palabras_clave, contenido_html_sin_separar,  '\n'.join(xpaths_contenido_html), '']
    
                            except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                                df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', xpath_a_buscar,  palabras_clave, contenido_html_sin_separar, '', '']
    
                    except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                        pass
    
                # Convertimos contenido_html a lista, pues posteriormente se utilizará para comprobar si acciones como un clic hace que se muestre nuevo contenido
                contenido_html = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', elementos_encontrados[0].get_attribute('outerHTML'))
                contenido_html = contenido_html.split('><')
                contenido_html = [('<' + contenido) if contenido.startswith('<') is False else contenido for contenido in contenido_html]
                contenido_html = [(contenido + '>') if contenido.endswith('>') is False else contenido for contenido in contenido_html]
    
                # Eliminamos aquellos elementos que puedan considerarse repetidos
                j = 0
                while j < len(datos_elementos_no_repetibles):
                    k = 0
                    while k < len(contenido_html):
                        if contenido_html[k] in datos_elementos_no_repetibles[j]:
                            datos_elementos_no_repetibles.remove(datos_elementos_no_repetibles[j])

                        else:
                            k = k + 1

                    j = j + 1

                for contenido in contenido_html:
                    xpath_a_aniadir = self.obtener_xpath_de_html(contenido)

                    if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():
                        try:
                            # Buscamos todos los elementos que haya en la página
                            elementos_encontrados = self.driver.find_elements(By.XPATH, xpath_a_aniadir + '//*')
                            elementos_encontrados = [elemento for elemento in elementos_encontrados if elemento.tag_name not in tags_a_eliminar]

                            for elemento in elementos_encontrados:
                                try:
                                    xpath_a_aniadir = self.obtener_xpath_de_elemento(elemento)

                                    if xpath_a_aniadir not in df_xpaths['XPATH'].tolist():# and '[' in xpath_a_aniadir:
                                        try:
                                            contenido_html_sin_separar = re.sub(r'\sdata[a-zA-Z0-9\-]{1,}=""|<!---->', '', elemento.get_attribute('outerHTML'))
                                            xpaths_contenido_html = self.obtener_xpaths_de_html(contenido_html_sin_separar)

                                            # Obtenemos las palabras clave, que serán de utilidad para poder buscar los xpaths necesarios
                                            palabras_clave = re.findall(r'\b\w+\b', xpath_a_aniadir)
                                            palabras_clave.append(re.sub(r'\d+\/\d+\/\d+|\d{2}:\d{2}', '', elemento.text).replace('\n\n', ',').replace('\n', ','))

                                            j = 10
                                            while j < len(palabras_clave):
                                                palabras_clave.insert(j, '\n')

                                                j = j + 10

                                            # Eliminamos los valores repetidos, ya que en este caso no es necesario tener valores duplicados
                                            palabras_clave = list(set(palabras_clave))
                                            palabras_clave = ','.join(palabras_clave)

                                            # Guardamos la imagen en un fichero, cuyo nombre será el del índice si se hizo captura
                                            if type(elemento.screenshot_as_png) is bytes:
                                                nombre_fichero_imagen = os.getcwd() + '\\capturas\\captura' + str(len(df_xpaths)) + '.png'
                                                df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, nombre_fichero_imagen, '', palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']

                                                # Guardamos la imagen en un fichero, cuyo nombre será el del índice
                                                elemento.screenshot(nombre_fichero_imagen)

                                        except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException):
                                            df_xpaths.loc[len(df_xpaths)] = [xpath_a_aniadir, '', '', palabras_clave, contenido_html_sin_separar, '\n'.join(xpaths_contenido_html), '']

                                except (selenium.common.exceptions.WebDriverException, selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.StaleElementReferenceException, selenium.common.exceptions.ElementClickInterceptedException):
                                    pass

                        except (selenium.common.exceptions.NoSuchElementException, selenium.common.exceptions.InvalidSelectorException, selenium.common.exceptions.ElementClickInterceptedException):
                            pass
    
                # Guardamos el fichero Excel
                self.guardar_df_como_excel(df_xpaths, 'xpaths.xlsx')
    
            except KeyboardInterrupt:
                # Guardamos fichero pickle para, en caso de volver a ejecutar, poder hacerlo desde donde nos hubiésemos quedado
                with open('df_xpaths.pickle', mode='wb') as fichero_pickle:
                    pickle.dump(df_xpaths, fichero_pickle)
    
                # Acciones como CTRL+C provocan este error. Lo capturamos para poder guardar lo hecho y por si se quiere revisar durante el proceso que va por buen camino
                print('Se ha detectado la ejecución de CTRL+C. Guardando hasta lo obtenido')
                self.guardar_df_como_excel(df_xpaths, 'xpaths.xlsx')

                return 'parado'
            
    def iniciar_sesion(self, params):
        if self.username is None:
            self.set_username_and_password()

        #self.driver.get("https://impact-neo-ced.enaire.es/#/login?redirect=%2Fmain%2Fmaster")
        self.driver.get('https://impact-formacion.enaire.es/')

        # Introducimos nombre de usuario
        if 'formacion' in self.driver.current_url:
            self.driver.find_element(By.ID, "input-17").send_keys(self.username)

        else:
            self.driver.find_element(By.ID, "input-16").send_keys(self.username)

        # Introducimos contraseña
        self.driver.find_element(By.ID, "password").send_keys(self.password)

        # Hacemos clic en el botón de login
        self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()
        self.driver.find_element(By.XPATH, '/html/body').send_keys(Keys.F11)
        time.sleep(3)

        if 'centro' in params.keys():
            #elemento = self.driver.find_element(By.XPATH, '//span[@class="dl-ui-select__label dl-ui-select__inputtext"]')
            self.hacer_clic({'xpath': '//span[@class="dl-ui-select__label dl-ui-select__inputtext"]'})

            match params['centro']:
                case 'GCCC' | 'Canarias' | 'CANARIAS':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="GCCC"]').click()

                case 'LECB' | 'Barcelona' | 'BARCELONA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECB"]').click()

                case 'LECM' | 'Madrid' | 'MADRID':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECM"]').click()

                case 'LECP' | 'Palma' | 'PALMA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECP"]').click()

                case 'LECS' | 'Sevilla' | 'SEVILLA':
                    self.driver.find_element(By.XPATH, '//li[@aria-label="LECS"]').click()

            self.driver.find_element(By.CSS_SELECTOR, ".mr-3 > strong").click()


    def cerrar_sesion(self):
        # Esperamos a que se pueda presionar el botón y que exista
        try:
            elemento = WebDriverWait(self.driver, 30).until(EC.presence_of_element_located((By.XPATH, '//div[@id="user"]//*/span/*[local-name()="svg"]/*[local-name()="path"]')))
            elements = self.driver.find_elements(By.XPATH, '//div[@id="user"]//*/span/*[local-name()="svg"]/*[local-name()="path"]')
            elements[-1].click()
        except selenium.common.TimeoutException:
            print('No se ha conseguido acceder al botón de cierre de sesión en 30seg')
            return None

        try:
            self.esperar_elemento({'esperar': {'xpath': '//div[@id="app"]/div/div/div/footer/button'}, 'tipo_espera': 'presencia'})
            self.hacer_clic({'xpath': '//div[@id="app"]/div/div/div/footer/button'})
            #elemento = WebDriverWait(self.driver, 30).until(EC.presence_of_element_located((By.XPATH, '//div[@id="app"]/div/div/div/footer/button')))
            #self.hacer_clic(elemento)

        except selenium.common.TimeoutException:
            print('No se ha conseguido acceder al botón de confirmación de cierre de sesión en 30seg')
            return None

        #elemento = self.driver.find_element(By.XPATH, '//div[@id="app"]/div/div/div/footer/button')
        #self.hacer_clic(elemento)

    def hacer_hover(self, params):
        elemento = self.buscar_elemento(params)
        ActionChains(self.driver).move_to_element(elemento).perform()

    def hacer_clic_derecho(self, params):
        elemento = self.buscar_elemento(params)
        ActionChains(self.driver).context_click(elemento).perform()

    def comprobar_elemento_habilitado(self, params):
        elemento = self.buscar_elemento(params)
        if params['habilitado']:
            print(elemento.is_enabled())

        else:
            print(elemento.is_enabled() is False)

    def comprobar_elementos_habilitados(self, params):
        elementos = self.buscar_elementos(params)
        for elemento in elementos:
            print(elemento.is_enabled())

    def comprobar_existencia_elemento(self, params):
        comprobacion_ok = False

        elemento = self.buscar_elemento(params)
        if (params['comprobar_existe'] and elemento is not None) or (params['comprobar_existe'] is False and elemento is None):
            comprobacion_ok = True

    def calcular_diferencia(self, params):
        pass

    def comprobar_posicion_relativa_elementos(self, params):
        encontrado = None
        match params['posicion']:
            case 'encima':
                encontrado = RelativeBy('xpath', params['elemento_1']['xpath']).above(self.buscar_elemento(params['elemento_2']))

            case 'debajo':
                encontrado = RelativeBy('xpath', params['elemento_1']['xpath']).below(self.buscar_elemento(params['elemento_2']))

            case 'a la izquierda':
                encontrado = RelativeBy('xpath', params['elemento_1']['xpath']).toLeftOf(self.buscar_elemento(params['elemento_2']))

            case 'a la derecha':
                encontrado = RelativeBy('xpath', params['elemento_1']['xpath']).toRightOf(self.buscar_elemento(params['elemento_2']))

            case 'cerca':
                # Estar cerca es estar ambos a una distancia máxima de 50px
                encontrado = RelativeBy('xpath', params['elemento_1']['xpath']).near(self.buscar_elemento(params['elemento_2']))

        print('Comprobacion ok', encontrado is not None)

    def comparar_elementos(self, params):
        valor_elemento_1 = None
        valor_elemento_2 = None
        elemento_1 = self.buscar_elemento(params['elemento_1'])
        if elemento_1 is not None:
            if 'atributo' in params['elemento_1'].keys():
                valor_elemento_1 = elemento_1.get_attribute(params['elemento_1']['atributo'])

            elif 'valor_guardado' in params['elemento_1'].keys():
                valor_elemento_1 = self.valores_guardados[params['elemento_1']['id']]

            else:
                valor_elemento_1 = len(self.buscar_elementos(params['elemento_1']))

        elemento_2 = self.buscar_elemento(params['elemento_2'])
        if elemento_2 is not None:
            if 'atributo' in params['elemento_2'].keys():
                valor_elemento_2 = elemento_2.get_attribute(params['elemento_2']['atributo'])

            elif 'valor_guardado' in params['elemento_2'].keys():
                valor_elemento_2 = self.valores_guardados[params['elemento_2']['id']]

            else:
                valor_elemento_2 = len(self.buscar_elementos(params['elemento_2']))

        match params['tipo_comprobacion']:
            case 'igual':
                comprobacion_ok = valor_elemento_1 == valor_elemento_2

            case 'distinto' | 'distintos':
                comprobacion_ok = valor_elemento_1 != valor_elemento_2

            case 'menor':
                comprobacion_ok = valor_elemento_1 < valor_elemento_2

            case 'mayor':
                comprobacion_ok = valor_elemento_1 > valor_elemento_2

            case 'menor o igual':
                comprobacion_ok = valor_elemento_1 <= valor_elemento_2

            case 'mayor o igual':
                comprobacion_ok = valor_elemento_1 >= valor_elemento_2

    def comprobar_cantidad_elementos(self, params):
        elementos = self.buscar_elementos(params)
        match params['tipo_comprobacion']:
            case 'obtener':
                self.valores_guardados[params['id']] = len(elementos)

            case 'igual':
                comprobacion_ok = len(elementos) == params['cantidad']

            case 'menor':
                comprobacion_ok = len(elementos) < params['cantidad']

            case 'mayor':
                comprobacion_ok = len(elementos) > params['cantidad']

            case 'menor o igual':
                comprobacion_ok = len(elementos) <= params['cantidad']

            case 'mayor o igual':
                comprobacion_ok = len(elementos) <= params['cantidad']


    def comprobar_existencia_elementos(self, params):
        elementos_a_comprobar = params['comprobar']
        match params['tipo_comprobacion'].upper():
            case 'Y' | 'AND':
                comprobacion_ok = True
                i = 0
                while i < len(elementos_a_comprobar) and comprobacion_ok:
                    elemento = self.buscar_elemento(elementos_a_comprobar[i])
                    if (params['comprobar_existe'] and elemento is None) or (params['comprobar_existe'] is False and elemento is not None):
                        comprobacion_ok = False

                    i = i + 1

            case 'O' | 'OR':
                comprobacion_ok = False
                i = 0
                while i < len(elementos_a_comprobar):
                    elemento = self.buscar_elemento(elementos_a_comprobar[i])
                    if (params['comprobar_existe'] and elemento is not None) or (params['comprobar_existe'] is False and elemento is None):
                        comprobacion_ok = True
                        break

                    i = i + 1


    def hacer_si_no_existe(self, params):
        if 'buscar' in params.keys():
            elemento = self.buscar_elemento(params['buscar'])
            if elemento is None:
                for accion in params['hacer']:
                    pass

        else:
            pass

    def guardar_valor(self, params):
        elemento = self.buscar_elemento(params)
        match params['valor_a_guardar'].keys():
            case 'texto':
                self.valores_guardados[params['id']] = elemento.text

            case 'regex':
                texto = re.search(params['regex'], elemento.text)
                if texto is not None:
                    self.valores_guardados[params['id']] = texto.group(0)

            case 'html':
                self.valores_guardados[params['id']] = self.buscar_elemento(params).get_attribute('outerHTML')
